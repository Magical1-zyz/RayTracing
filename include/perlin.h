//
// Created by ASUS on 2025/2/24.
//

#ifndef RAYTRACINGINONEWEEKEND_INCLUDE_PERLIN_H_
#define RAYTRACINGINONEWEEKEND_INCLUDE_PERLIN_H_
/************************
 * @Author: Magical1
 * @Time: 2025/2/24 20:00
 * @File: perlin.h
 * @Software: CLion
 * @Project: RayTracingInOneWeekend
 * @Description:The perlin class generates Perlin noise.
 * Perlin noise is a type of gradient noise that was developed by Ken Perlin in 1983.
 * It is commonly used in computer graphics for effects like textures, fire, smoke, and clouds.
 * Perlin noise is a pseudo-random function that produces a more natural-appearing texture.
 * It is a type of gradient noise, which means that it is generated by combining multiple
 * noise functions of different frequencies and amplitudes.
 * The Perlin noise function is continuous, which means that it is smooth and has no abrupt changes.
 * This makes it ideal for generating textures and other effects that require a smooth appearance.
 */

#include "rtweekend.h"

class perlin {
 public:
  perlin() {
    for (auto & i : randvec) {
      i = unit_vector(vec3::random(-1, 1));
    }

    perlin_generate_perm(perm_x);
    perlin_generate_perm(perm_y);
    perlin_generate_perm(perm_z);
  }

  double noise(const point3& p) const {
    auto u = p.x() - std::floor(p.x()); // Fractional part of p.x
    auto v = p.y() - std::floor(p.y()); // Fractional part of p.y
    auto w = p.z() - std::floor(p.z()); // Fractional part of p.z

//    // Hermitian smoothing
//    // Hermite polynomial: H3(x) = yo(1+2u)(1-u)^2 + y1(1-2(u-1))u^2 + mo(x-x0)(1-u)^2 + m1(x-x1)u^2
//    // yo=0,y1=1,m0=m1=0(linear interpolation),x0=0,x1=1
//    // H3(x)=3u^2 - 2u^3
//    u = u*u*(3-2*u);
//    v = v*v*(3-2*v);
//    w = w*w*(3-2*w);

    auto i = int(std::floor(p.x()));
    auto j = int(std::floor(p.y()));
    auto k = int(std::floor(p.z()));
//    double c[2][2][2];
    vec3 c[2][2][2];

    for (int di = 0; di < 2; ++di)
      for (int dj = 0; dj < 2; ++dj)
        for (int dk = 0; dk < 2; ++dk)
          c[di][dj][dk] = randvec[
              perm_x[(i+di) & 255] ^
              perm_y[(j+dj) & 255] ^
              perm_z[(k+dk) & 255]
          ];

    return perlin_interp(c, u, v, w);
  }

  double turb(const point3& p, int depth) const {
    // The turb function generates a sum of repeated calls to noise.
    auto accum  = 0.0;
    auto temp_p = p;
    auto weight = 1.0;

    for (int i = 0; i < depth; ++i) {
      accum += weight * noise(temp_p);
      weight *= 0.5;
      temp_p *= 2;
    }

    return std::fabs(accum);
  }

private:
  static const int point_count = 256;
//  double randfloat[point_count];
  vec3 randvec[point_count];
  int perm_x[point_count]{};
  int perm_y[point_count]{};
  int perm_z[point_count]{};

  static void perlin_generate_perm(int* p) {
    // Fill the array p[] with random values.
    for (int i = 0; i < point_count; ++i) {
      p[i] = i;
    }
    permute(p, point_count);
  }

  static void permute(int* p, int n) {
    // Shuffle the array p[].
    // Fisher-Yates shuffle.
    for (int i = n-1; i > 0; i--) {
      int target = random_int(0, i);
      int tmp = p[i];
      p[i] = p[target];
      p[target] = tmp;
    }
  }

  static double perlin_interp(const vec3 c[2][2][2], double u, double v, double w) {
    // Hermitian smoothing
    // Hermite polynomial: H3(x) = yo(1+2u)(1-u)^2 + y1(1-2(u-1))u^2 + mo(x-x0)(1-u)^2 + m1(x-x1)u^2
    // yo=0,y1=1,m0=m1=0(linear interpolation),x0=0,x1=1
    // H3(x)=3u^2 - 2u^3
    auto uu = u*u*(3-2*u);
    auto vv = v*v*(3-2*v);
    auto ww = w*w*(3-2*w);
    auto accum = 0.0;

    // Interpolate the value of the trilinear interpolation.
    for (int i = 0; i < 2; ++i)
      for (int j = 0; j < 2; ++j)
        for (int k = 0; k < 2; ++k) {
          vec3 weight_v(u-i, v-j, w-k); // weight_v:the offset of the sample points relative to the mesh corners
          accum += (i*uu + (1-i)*(1-uu)) *
                   (j*vv + (1-j)*(1-vv)) *
                   (k*ww + (1-k)*(1-ww)) *
                   dot(c[i][j][k], weight_v);
        }

    return accum;
  }

//  static double trilinear_interp(double c[2][2][2], double u, double v, double w) {
//    // Interpolate the value of the trilinear interpolation.
//    auto accum = 0.0;
//    for (int i = 0; i < 2; i++)
//      for (int j = 0; j < 2; j++)
//        for (int k = 0; k < 2; k++)
//          accum += (i*u + (1-i)*(1-u)) *
//                   (j*v + (1-j)*(1-v)) *
//                   (k*w + (1-k)*(1-w)) *
//                   c[i][j][k];
//
//    return accum;
//  }
};
#endif //RAYTRACINGINONEWEEKEND_INCLUDE_PERLIN_H_
